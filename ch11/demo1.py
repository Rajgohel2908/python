# completion_script.py

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import collections
import copy
import inspect

from fire import inspectutils
import six
import fire


def Script(name, component, default_options=None, shell='bash'):
    if shell == 'fish':
        return _FishScript(name, _Commands(component), default_options)
    return _BashScript(name, _Commands(component), default_options)


def _BashScript(name, commands, default_options=None):
    default_options = default_options or set()
    global_options, options_map, subcommands_map = _GetMaps(name, commands, default_options)

    bash_completion_template = """# bash completion support for {name}
# DO NOT EDIT.
# This script is autogenerated by fire/completion.py.
_complete-{identifier}()
{{
  local cur prev opts lastcommand
  COMPREPLY=()
  prev="${{COMP_WORDS[COMP_CWORD-1]}}"
  cur="${{COMP_WORDS[COMP_CWORD]}}"
  lastcommand=$(get_lastcommand)
  opts="{default_options}"
  GLOBAL_OPTIONS="{global_options}"
{checks}
  COMPREPLY=( $(compgen -W "${{opts}}" -- ${{cur}}) )
  return 0
}}
get_lastcommand()
{{
  local lastcommand i
  lastcommand=
  for ((i=0; i < ${{#COMP_WORDS[@]}}; ++i)); do
    if [[ ${{COMP_WORDS[i]}} != -* ]] && [[ -n ${{COMP_WORDS[i]}} ]] && [[
      ${{COMP_WORDS[i]}} != $cur ]]; then
      lastcommand=${{COMP_WORDS[i]}}
    fi
  done
  echo $lastcommand
}}
filter_options()
{{
  local opts
  opts=""
  for opt in "$@"
  do
    if ! option_already_entered $opt; then
      opts="$opts $opt"
    fi
  done
  echo $opts
}}
option_already_entered()
{{
  local opt
  for opt in ${{COMP_WORDS[@]:0:COMP_CWORD}}
  do
    if [ $1 == $opt ]; then
      return 0
    fi
  done
  return 1
}}
is_prev_global()
{{
  local opt
  for opt in $GLOBAL_OPTIONS
  do
    if [ $opt == $prev ]; then
      return 0
    fi
  done
  return 1
}}
complete -F _complete-{identifier} {command}
"""

    check_wrapper = """
  case "${{lastcommand}}" in
  {lastcommand_checks}
  esac"""

    lastcommand_check_template = """
    {command})
      {opts_assignment}
      opts=$(filter_options $opts)
    ;;"""

    opts_assignment_subcommand_template = """
      if is_prev_global; then
        opts="${{GLOBAL_OPTIONS}}"
      else
        opts="{options} ${{GLOBAL_OPTIONS}}"
      fi"""

    opts_assignment_main_command_template = """
      opts="{options} ${{GLOBAL_OPTIONS}}" """

    def _GetOptsAssignmentTemplate(command):
        if command == name:
            return opts_assignment_main_command_template
        else:
            return opts_assignment_subcommand_template

    lines = []
    for command in set(subcommands_map.keys()).union(set(options_map.keys())):
        opts_assignment = _GetOptsAssignmentTemplate(command).format(
            options=' '.join(sorted(options_map[command].union(subcommands_map[command]))),
        )
        lines.append(
            lastcommand_check_template.format(
                command=command,
                opts_assignment=opts_assignment)
        )
    lastcommand_checks = '\n'.join(lines)

    checks = check_wrapper.format(
        lastcommand_checks=lastcommand_checks,
    )

    return (
        bash_completion_template.format(
            name=name,
            command=name,
            checks=checks,
            default_options=' '.join(default_options),
            identifier=name.replace('/', '').replace('.', '').replace(',', ''),
            global_options=' '.join(global_options),
        )
    )


def _FishScript(name, commands, default_options=None):
    default_options = default_options or set()
    global_options, options_map, subcommands_map = _GetMaps(name, commands, default_options)

    fish_source = """function __fish_using_command
    set cmd (commandline -opc)
    for i in (seq (count $cmd) 1)
        switch $cmd[$i]
        case "-*"
        case "*"
            if [ $cmd[$i] = $argv[1] ]
                return 0
            else
                return 1
            end
        end
    end
    return 1
end
function __option_entered_check
    set cmd (commandline -opc)
    for i in (seq (count $cmd))
        switch $cmd[$i]
        case "-*"
            if [ $cmd[$i] = $argv[1] ]
                return 1
            end
        end
    end
    return 0
end
function __is_prev_global
    set cmd (commandline -opc)
    set global_options {global_options}
    set prev (count $cmd)
    for opt in $global_options
        if [ "--$opt" = $cmd[$prev] ]
            echo $prev
            return 0
        end
    end
    return 1
end
"""

    subcommand_template = ("complete -c {name} -n '__fish_using_command "
                           "{command}' -f -a {subcommand}\n")
    flag_template = ("complete -c {name} -n "
                     "'__fish_using_command {command};{prev_global_check} and "
                     "__option_entered_check --{option}' -l {option}\n")

    prev_global_check = ' and __is_prev_global;'
    for command in set(subcommands_map.keys()).union(set(options_map.keys())):
        for subcommand in subcommands_map[command]:
            fish_source += subcommand_template.format(
                name=name,
                command=command,
                subcommand=subcommand,
            )

        for option in options_map[command].union(global_options):
            check_needed = command != name
            fish_source += flag_template.format(
                name=name,
                command=command,
                prev_global_check=prev_global_check if check_needed else '',
                option=option.lstrip('--'),
            )

    return fish_source.format(
        global_options=' '.join(
            '"{option}"'.format(option=option)
            for option in global_options
        )
    )


def MemberVisible(component, name, member, class_attrs=None, verbose=False):
    if isinstance(name, six.string_types) and name.startswith('__'):
        return False
    if verbose:
        return True
    if (member is absolute_import
        or member is division
        or member is print_function):
        return False
    if isinstance(member, type(absolute_import)) and six.PY34:
        return False
    if inspect.ismodule(member) and member is six:
        return False
    if inspect.isclass(component):
        if class_attrs is None:
            class_attrs = inspectutils.GetClassAttrsDict(class_attrs) or {}
        class_attr = class_attrs.get(name)
        if class_attr:
            if class_attr.kind in ('method', 'property'):
                return False
            tuplegetter = getattr(collections, '_tuplegetter', type(None))
            if isinstance(class_attr.object, tuplegetter):
                return False
    if (six.PY2 and inspect.isfunction(component)
        and name in ('func_closure', 'func_code', 'func_defaults',
                     'func_dict', 'func_doc', 'func_globals', 'func_name')):
        return False
    if (six.PY2 and inspect.ismethod(component)
        and name in ('im_class', 'im_func', 'im_self')):
        return False
    if isinstance(name, six.string_types):
        return not name.startswith('_')
    return True


def VisibleMembers(component, class_attrs=None, verbose=False):
    if isinstance(component, dict):
        members = component.items()
    else:
        members = inspect.getmembers(component)

    if class_attrs is None:
        class_attrs = inspectutils.GetClassAttrsDict(component)
    return [
        (member_name, member) for member_name, member in members
        if MemberVisible(component, member_name, member, class_attrs=class_attrs,
                         verbose=verbose)
    ]


def _CompletionsFromArgs(fn_args):
    completions = []
    for arg in fn_args:
        arg = arg.replace('_', '-')
        completions.append('--{arg}'.format(arg=arg))
    return completions


def Completions(component, verbose=False):
    if inspect.isroutine(component) or inspect.isclass(component):
        spec = inspectutils.GetFullArgSpec(component)
        return _CompletionsFromArgs(spec.args + spec.kwonlyargs)

    if isinstance(component, (tuple, list)):
        return [str(index) for index in range(len(component))]

    if inspect.isgenerator(component):
        return []

    return [
        _FormatForCommand(member_name)
        for member_name, _ in VisibleMembers(component, verbose=verbose)
    ]


def _FormatForCommand(token):
    if not isinstance(token, six.string_types):
        token = str(token)

    if token.startswith('_'):
        return token

    return token.replace('_', '-')


def _Commands(component, depth=3):
    if inspect.isroutine(component) or inspect.isclass(component):
        for completion in Completions(component, verbose=False):
            yield (completion,)
        if inspect.isroutine(component):
            return

    if depth < 1:
        return

    for member_name, member in VisibleMembers(component, class_attrs={},
                                              verbose=False):
        member_name = _FormatForCommand(member_name)

        yield (member_name,)

        for command in _Commands(member, depth - 1):
            yield (member_name,) + command


def _IsOption(arg):
    return arg.startswith('-')


def _GetMaps(name, commands, default_options):
    global_options = copy.copy(default_options)
    options_map = collections.defaultdict(lambda: copy.copy(default_options))
    subcommands_map = collections.defaultdict(set)

    for command in commands:
        if len(command) == 1:
            if _IsOption(command[0]):
                global_options.add(command)
            else:
                subcommands_map[name].add(command)
        elif command:
            subcommand = command[-2]
            arg = _FormatForCommand(command[-1])

            if _IsOption(arg):
                args_map = options_map
            else:
                args_map = subcommands_map

            args_map[subcommand].add(arg)
            args_map[subcommand.replace('_', '-')].add(arg)

    return global_options, options_map, subcommands_map


# Simple example CLI to demonstrate

class ExampleCLI:
    def greet(self, name='World'):
        """Greet a person with a name."""
        print(f"Hello, {name}!")

    def add(self, x: int, y: int):
        """Add two numbers."""
        print(f"The result of {x} + {y} is {x + y}")

    def multiply(self, x: int, y: int):
        """Multiply two numbers."""
        print(f"The result of {x} * {y} is {x * y}")

if __name__ == '__main__':
    import sys

    if '--generate-completion' in sys.argv:
        # Generate bash completion script and print it
        script = Script('example', ExampleCLI, shell='bash')
        print(script)
    else:
        # Run the CLI normally via Fire
        fire.Fire(ExampleCLI)
